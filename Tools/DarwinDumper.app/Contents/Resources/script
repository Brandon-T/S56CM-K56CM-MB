#!/bin/sh

# A script to launch DarwinDumper and respond to user input.
# Copyright (C) 2013 Blackosx
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#    
# =======================================================================
#
# This script responds to user input and launches DarwinDumper
# either via the user interface or the command line depending
# on how it was run.
#
# The user interface gathers the options the user wants and
# then writes those options to a file ready for the main 
# DarwinDumper script to read.
#
# Alternatively, command line options are parsed and written
# to file ready for the main DarwinDumper script to read.
#
# This script then sits and waits until the UI terminates
# before also terminating.
#

gFaceless=0 # Set to 1 to build app which when double-clicked does not show UI but runs all without root privileges.

gDDTmpFolder="/tmp/DarwinDumper" # Temporary working folder.
gReportsFolderPath="" # Directory path for DarwinDumper reports.
gTmpPreLogFile="$gDDTmpFolder"/tmplogfile
gUserPrefsFileName="org.tom.DarwinDumper"
gUserPrefsFile="$HOME/Library/Preferences/$gUserPrefsFileName"
VERS="2.9.6"

# ---------------------------------------------------------------------------------------
Initialise()
{
    passedCaller="$1"
    asUser="$2"
    
    # write version to temp file for UI to use.
    # Previously used export fails when running as root.
    echo "$VERS" > "$gDDTmpFolder"/dd_version

    gAppReportsFolderName="DarwinDumperReports"
    gUiPwCancelledStr="zYx1!dd_User_Cancelled!!xYz"
    
    # Here we save the current user and group ID's and use them in the
    # DarwinDumper script when setting ownership/permissions of the dump
    # folder, even if the user opt to run the dumps with root privileges.
    DD_BOSS=`id -unr` #export DD_BOSS=`id -unr`
    DD_BOSSGROUP=`id -gnr` #export DD_BOSSGROUP=`id -gnr`
    
    # The problem with the above is if the user has invoked sudo with root privileges
    # and runs DarwinDumper then the UID will be root and the DarwinDumperReports folder
    # will be created and owned by root.
    # Here we check to see if the current user is root and if yes then change it
    # using the environment variable $HOME. 
    # ** THIS NEEDS CHECKING - Does it work for everyone?
    if [ "$DD_BOSS" == "root" ]; then
        DD_BOSS=$(echo "${HOME##*/}")
        DD_BOSSGROUP=`id -g -n ${DD_BOSS}` 
    fi    
    
    # The above works great when using the command line, but not the UI.
    # So we need to write them to a file instead and read them later.
    echo "${DD_BOSS}:${DD_BOSSGROUP}" > "$gDDTmpFolder"/dd_user
    
    # From http://stackoverflow.com/questions/7665/how-to-resolve-symbolic-links-in-a-shell-script/697552#697552
    # get the absolute path of the executable
    SELF_PATH=$(cd -P -- "$(dirname -- "$0")" && pwd -P) && SELF_PATH=$SELF_PATH/$(basename -- "$0")

    # resolve symlinks
    while [ -h "$SELF_PATH" ]; do
        # 1) cd to directory of the symlink
        # 2) cd to the directory of where the symlink points
        # 3) get the pwd
        # 4) append the basename
        DIR=$(dirname -- "$SELF_PATH")
        SYM=$(readlink "$SELF_PATH")
        SELF_PATH=$(cd $DIR && cd $(dirname -- "$SYM") && pwd)/$(basename -- "$SYM")
    done

    # The final platypus built app has this script located at:
    # /DarwinDumper.app/Contents/Resources/script
    # So to find the application containing directory we have to move up 4 dirs.
    appRootPath="${SELF_PATH}"
    for (( x=1; x<=4; x++ ))
    do
        appRootPath="${appRootPath%/*}"
    done

    # Write actual app path to file also, so UI can compare paths
    # To know if a custom path is being used.
    echo "$appRootPath" > "$gDDTmpFolder"/dd_app_root_path

    # Check prefs for previously used settings and to find if the user
    # previously set a custom directory for the DarwinDumperReports folder.
    if [ $gFaceless -eq 0 ]; then
        LoadPreviousSettingsFromUserPrefs
    fi

    local resourcesDir="${SELF_PATH%/*}"
    if [ -d "$resourcesDir" ]; then
        local scriptsDir="$resourcesDir"/Scripts
        darwinDumperScript="$scriptsDir/DarwinDumper.sh"
        macgap="$resourcesDir/MacGap.app/Contents/MacOS/MacGap"
        uiSudoChanges="$resourcesDir/Scripts/uiSudoChangeRequests.sh"

        if [ "$passedCaller" == "Script" ]; then
            runUI
        elif [ "$passedCaller" == "CommandLine" ]; then
            runCommandLine "$asUser"
        fi
    else
        echo "DarwinDumper quit because it couldn't find the Resources folder."
        exit 1
    fi
}

# ---------------------------------------------------------------------------------------
CheckAndFixBlankSavePath()
{
    # Is the current save path blank?
    # If yes, then set the save path to the app containing dir.
    if [ "$gReportsFolderPath" == "" ]; then
        gReportsFolderPath="$appRootPath"
        echo "*Save path - Default: Will use $gReportsFolderPath" >> "$gTmpPreLogFile"
    fi
}
    
# ---------------------------------------------------------------------------------------
CheckForExistingReportsDirAndAppend()
{
    # check for existing DarwinDumperReports dir at save location.
    if [ -d "$gReportsFolderPath"/"${gAppReportsFolderName}" ]; then
        gReportsFolderPath="$gReportsFolderPath"/"${gAppReportsFolderName}"
    fi
}

# ---------------------------------------------------------------------------------------
DoesSavePathExist()
{
    passedPath="$1"
    if [ -d "$passedPath" ]; then
        echo "*Save path verify: Path exists." >> "${gTmpPreLogFile}"
        return 0
    else
        echo "*Save path verify: Path does not exist." >> "${gTmpPreLogFile}"
        return 1
    fi
}

# ---------------------------------------------------------------------------------------
CheckPathIsWriteable()
{
    local passedDir="$1"
    
    local isWriteable=1
    touch "$passedDir"/test 2>/dev/null && rm -f "$passedDir"/test || isWriteable=0
    local reportsFolderOwner=$( ls -ld "$passedDir" | awk '{print $3}' )

    if [ ! "$DD_BOSS" == "$reportsFolderOwner" ] || [ $isWriteable -eq 0 ]; then
        echo "*Save path verify: Path is not writeable." >> "${gTmpPreLogFile}"
        return 1
    else
        echo "*Save path verify: Path is writeable." >> "${gTmpPreLogFile}"
        return 0
    fi
}

# ---------------------------------------------------------------------------------------
CheckSavePathForReportsName()
{
    # Does the current save path end with DarwinDumperReports?
    local tmp="${gReportsFolderPath##*/}"
    if [ "$tmp" == "$gAppReportsFolderName" ]; then
        echo "*Save path verify: Path ends with ${gAppReportsFolderName}." >> "${gTmpPreLogFile}"
        return 0
    else
        echo "*Save path verify: Path does not end with ${gAppReportsFolderName}." >> "${gTmpPreLogFile}"
        return 1
    fi
}

# ---------------------------------------------------------------------------------------
createSaveDirAndSetPermissions()
{
    declare -a list
    
    MatchNameToID()
    {
        local match=""
        for (( i=0; i<${#list[@]}; i++ ))
        do
            if [[ "${list[$i]}" == *$1* ]]; then
                match="${list[$i]##*=}"
                match="${match%(*}"
                break
            fi
        done
        echo "$match"
    }
    
    local passedDir="$1"
    local passedCommand="$2"
    local passedTask="$3"
    local passedCaller="$4"
    local passedMessage="$5"
    
    if [ "$passedCommand" == "normal" ]; then
        if [ "$passedTask" == "CreateSet" ]; then
            # The path is writeable so create directory
            echo "*Save path: Creating ${passedDir}" >> "${gTmpPreLogFile}"
            mkdir "${passedDir}"
        fi
    fi
    
    if [ "$passedCommand" == "sudo" ]; then
        if [ "$passedTask" == "CreateSet" ]; then
            # The path is not writeable so create directory with root privileges
            if [ "$passedCaller" == "UI" ]; then
                GetAndCheckUIPassword "$passedMessage"
                local returnValueRoot=$? # 1 = not root / 0 = root

                if [ ${returnValueRoot} = 0 ] && [ ! "$gPw" == "" ]; then 
                    echo "*Save path: Creating ${passedDir} and setting permissions." >> "${gTmpPreLogFile}"
                    echo "$gPw" | sudo -S "$uiSudoChanges" "CreateFolderSetPerms" "${DD_BOSS}" "${DD_BOSSGROUP}" "${passedDir}" && gPw=""
                
                    echo "*Save path: Setting permissions for ${gReportsFolderPath}." >> "${gTmpPreLogFile}"
                    echo "$gPw" | sudo -S "$uiSudoChanges" "OwnPerm" "${DD_BOSS}" "${DD_BOSSGROUP}" "${passedDir}" && gPw=""
                fi
            elif [ "$passedCaller" == "CL" ]; then
                echo "Creating ${passedDir}"
                sudo mkdir "${passedDir}"
                echo "Setting owner and group to ${DD_BOSS}:${DD_BOSSGROUP}"
                sudo chown "${DD_BOSS}":"${DD_BOSSGROUP}" "${passedDir}" 
                echo "Setting permissions to 755"   
                sudo chmod -R 755 "${passedDir}" 
            fi
        fi
        if [ "$passedTask" == "Set" ]; then
            # The path is not writeable so create directory with root privileges
            if [ "$passedCaller" == "UI" ]; then
                GetAndCheckUIPassword "$passedMessage"
                local returnValueRoot=$? # 1 = not root / 0 = root

                if [ ${returnValueRoot} = 0 ] && [ ! "$gPw" == "" ]; then 
                    echo "*Save path: Setting permissions for ${gReportsFolderPath}." >> "${gTmpPreLogFile}"
                    echo "$gPw" | sudo -S "$uiSudoChanges" "OwnPerm" "${DD_BOSS}" "${DD_BOSSGROUP}" "${passedDir}" && gPw=""
                fi
            elif [ "$passedCaller" == "CL" ]; then
                echo "Setting owner and group to ${DD_BOSS}:${DD_BOSSGROUP}"
                sudo chown "${DD_BOSS}":"${DD_BOSSGROUP}" "${passedDir}"
                echo "Setting recursive permissions to 755" 
                sudo chmod -R 755 "${passedDir}" 
            fi
        fi
    fi

    # Check success.
    local reportsPerms=$( stat -f "%p" "${passedDir}" )
    local reportsDirUser=$( stat -f "%u" "${passedDir}" ) # will be the number
    local reportsDirGroup=$( stat -f "%g" "${passedDir}" ) # will be the number
    reportsPerms=${reportsPerms:2:5}

    # cross reference the ID numbers against the names we wanted to set using ${DD_BOSS}:${DD_BOSSGROUP}
    oIFS="$IFS"; IFS=$' ,'
    list=( $(id) )
    IFS="$oIFS"

    local ddBossUID=$(MatchNameToID "${DD_BOSS}")
    local ddBossGID=$(MatchNameToID "${DD_BOSSGROUP}")
    
    echo "*Save path: Currently owned by user:$reportsDirUser of group:$reportsDirGroup with permissions: $reportsPerms" >> "${gTmpPreLogFile}"

    # Return success or failure
    if [ "$reportsDirUser" == "$ddBossUID" ] && [ "$reportsDirGroup" == "$ddBossGID" ]; then
        echo "*Save path: ${passedDir} is now owned by ${DD_BOSS}:${DD_BOSSGROUP} with permissions $reportsPerms" >> "${gTmpPreLogFile}"
        if [ ${reportsPerms:0:1} == "7" ]; then
            if [ "$passedCaller" == "CL" ]; then
                echo "${passedDir} has permissions $reportsPerms"
                echo "------------------------------------------------------------------------"
            fi
            return 0
        else
            echo "*Save path: Failed to change permissions for ${passedDir}" >> "${gTmpPreLogFile}"
            if [ "$passedCaller" == "CL" ]; then
                echo "*** Failed to change permissions for ${passedDir}"
                echo "------------------------------------------------------------------------"
            fi
            return 1
        fi
    else
        echo "*Save path: Ownership error for ${passedDir}" >> "${gTmpPreLogFile}"
        echo "*Save path: Failed to match user:$ddBossUID of group:$ddBossGID" >> "${gTmpPreLogFile}"
        if [ "$passedCommand" == "sudo" ]; then
            echo "*Save path: Failed to change ownership/permissions for ${passedDir}" >> "${gTmpPreLogFile}"
        fi
        
        if [ "$passedCaller" == "CL" ]; then
            echo "*** Failed to change ownership/permissions for ${passedDir}"
        fi
        return 1
    fi 
}

# ---------------------------------------------------------------------------------------
BailOut()
{
    local passedMessage="$1"

    echo "$passedMessage"
    echo "Exiting."
    DeleteTempWorkingDirectory
    echo "Bye."
    exit 1
}

# ---------------------------------------------------------------------------------------
CheckForUpdate()
{
    # Simple check to compare version number of this version number against the
    # newest download file on bitbucket. If there's a difference then the version number
    # from bitbucket is written to tmp/dd_update for reading by darwindumper.js 
    if [ -f /usr/bin/curl ]; then
        local testConnection=$( /usr/bin/curl --silent --head https://bitbucket.org/blackosx/darwindumper/downloads | egrep "OK"  )
        if [ "$testConnection" ]; then
            local checkVer=""
            checkVer=$( /usr/bin/curl --silent https://bitbucket.org/blackosx/darwindumper/downloads | grep DarwinDumper_v*.*.*.zip | head -n 1 )
            if [ "$checkVer" == "" ]; then
                echo "No update available." >> "$gTmpPreLogFile"
            else
                # Strip version from returned line
                checkVer="${checkVer##*DarwinDumper_v}"
                checkVer="${checkVer%.zip*}"

                # Remove any non-numeric chars from version numbers
                local checkNewVerNumber=$( echo "$checkVer" | sed 's/\([0-9][0-9]*\)[^0-9]*/\1/g' )
                local checkCurrentVerNumber=$( echo "$VERS" | sed 's/\([0-9][0-9]*\)[^0-9]*/\1/g' )

                if [ $checkNewVerNumber -gt $checkCurrentVerNumber ]; then
                    echo "*Version check: Newer v${checkVer} is available." >> "$gTmpPreLogFile"
                    echo "$checkVer" > "$gDDTmpFolder"/dd_update
                else
                    echo "*Version check: This is the latest version." >> "$gTmpPreLogFile"
                fi
            fi
        fi
    fi
}

# ---------------------------------------------------------------------------------------
LoadPreviousSettingsFromUserPrefs()
{
    # Check for preferences file
    if [ -f "$gUserPrefsFile".plist ]; then

        oIFS="$IFS"; IFS=$'\n'
        local readVar=( $( defaults read "$gUserPrefsFile" 2>/dev/null ) )
        IFS="$oIFS"
        
        # get total count of lines, less one for zero based index.
        local count=(${#readVar[@]}-1)

        # Check first line and last line of prefs file actually is an open and closing curly brace.
        if [[ "${readVar[0]}" == "{" ]] && [[ "${readVar[$count]}" == "}" ]]; then
            echo "*Reading ${gUserPrefsFile}.plist" >> "$gTmpPreLogFile"

            # Ignore first and last elements as they will be an opening and closing brace. 
            for (( x=1; x<$count; x++ ))
            do
                # separate items
                local tmpOption="${readVar[$x]%=*}"
                local tmpValue="${readVar[$x]#*=}"
                # Remove whitespace
                tmpOption="${tmpOption//[[:space:]]}"

                # Check for save directory.
                if [ "$tmpOption" == "SaveDirectory" ]; then
                    # Remove quotes and semicolon from the returned string
                    tmpValue=$( echo "$tmpValue" | tr -d '";' )
                    # Remove any leading white space
                    tmpValue=$( echo "${tmpValue#* }" )
                    # Escape any spaces
                    tmpValue=$( echo "$tmpValue" | sed 's/ /\\ /g' )
                    gReportsFolderPath="$tmpValue"
                    echo "*Found save path $gReportsFolderPath" >> "$gTmpPreLogFile"
                else
                    # Remove whitespace
                    tmpValue="${tmpValue//[[:space:]]}"
                fi

                # If true AND the app was initiated from the Finder (not command line) then set options for loading.
                if [ "$tmpValue" == "True;" ]; then #&& [ "$passedCaller" == "Script" ]; then
                    # Check for enablehtml option from v2.9.2 and older and update with new ReportNew option for v2.9.3 and newer.
                    if [ "$tmpOption" == "enablehtml" ]; then
                        tmpOption="ReportNew"
                    fi
                    echo "$tmpOption" >> "$gDDTmpFolder"/dd_user_last_options
                    echo "*Found previous option: $tmpOption" >> "$gTmpPreLogFile"
                fi
            done
        else
            echo "*$gUserPrefsFile does not contain opening and closing curly braces." >> "$gTmpPreLogFile"
        fi
    else
        echo "*$gUserPrefsFile not found." >> "$gTmpPreLogFile"
    fi
}

# ---------------------------------------------------------------------------------------
CheckSymLink()
{
    if [ -L /usr/local/bin/darwindumper ]; then
        local checkSymLink=$( readlink -n /usr/local/bin/darwindumper )
        if [ ! "$checkSymLink" == "$SELF_PATH" ]; then
            # Existing symlink doesn't match this. Give the user the option to update?
            echo "*Symlink check: Symlink exists, but does not point to this version of the app." >> "$gTmpPreLogFile"
            # write status to temp file for UI to use.
            echo "Update" > "$gDDTmpFolder"/dd_symlink
        else
            echo "*Symlink check: Symlink exists and is correct." >> "$gTmpPreLogFile"
            echo "Okay" > "$gDDTmpFolder"/dd_symlink
        fi
    else
        # No symlink exists. Give the user the option to create one?
        echo "*Symlink check: Symlink has not been created." >> "$gTmpPreLogFile"
        # write status to temp file for UI to use.
        echo "Create" > "$gDDTmpFolder"/dd_symlink
    fi
}

# ---------------------------------------------------------------------------------------
ClearUIReturnMessages()
{
    # Clear "$gDDTmpFolder"/dd_ui_return so the main loop can
    # continue waiting for further user input
    if [ -f "$gDDTmpFolder"/dd_ui_return ]; then
        > "$gDDTmpFolder"/dd_ui_return
    fi
}

# ---------------------------------------------------------------------------------------
ClearAuthMessage()
{
    # Give the UI a chance to close the authentication message box
    # just incase it's stil visible.
    echo "Done" > "$gDDTmpFolder"/dd_auth 
    sleep 1
    
    # Remove user authentication message file for UI.
    if [ -f "$gDDTmpFolder"/dd_auth ]; then
        rm "$gDDTmpFolder"/dd_auth 
    fi
}

# ---------------------------------------------------------------------------------------
ClearUIErrorMessage()
{
    # Give the UI a chance to see this message and present dialog
    # box before deleting this message.
    sleep 1
    
    # Remove user authentication message file for UI.
    if [ -f "$gDDTmpFolder"/dd_error ]; then
        rm "$gDDTmpFolder"/dd_error 
    fi
}

# ---------------------------------------------------------------------------------------
GetNewSaveDirectory()
{
    # Send message to UI to tell it we're waiting for user action
    echo "Waiting" > "$gDDTmpFolder"/dd_waiting

    # show tiny dialog box - as an attempt to ensure choose folder dialog box is shown
    local tmp="$( /usr/bin/osascript -e 'Tell application "System Events" to display dialog "Click this button to continue. (Yes I know its stupid having this but Applescript from shell seems buggy!!)" buttons {"Show folder browser"}' 2>/dev/null )"
    
    #local myFolder="$( /usr/bin/osascript -e 'with timeout of 10 seconds' -e 'Tell application "System Events" to set sourceFolder to (choose folder with prompt "Select a new path for the DarwinDumperReports folder.") as text ' -e 'end timeout' 2>/dev/null)"
    local myFolder="$( /usr/bin/osascript -e 'Tell application "System Events" to set sourceFolder to (choose folder with prompt "Choose a save directory for the DarwinDumperReports folder to be created
or select an existing DarwinDumperReports folder.") as text ' 2>/dev/null)"

    if [ ! "$myFolder" == "" ]; then
 
        # Note: returned string will look something like this MountainLion:Users:whoever:Desktop:test:
        # Change colons to forward slashes
        myFolder=$( echo "$myFolder" | sed 's/:/\//g' )
        # Strip last character
        myFolder=$( echo "${myFolder%?}" )
        # Append /Volumes/
        myFolder="/Volumes/$myFolder"
        # Escape any spaces
        myFolder=$( echo "$myFolder" | sed 's/ /\\ /g' )

        # Is the new path different to what we had before?
        if [ ! "$myFolder" == "$gReportsFolderPath" ]; then 
            gReportsFolderPath="$myFolder"
            
            # Check if path contains parenthesis - if yes, do not write to prefs.
            if [[ ! "$gReportsFolderPath" == *\(* ]] && [[ ! "$gReportsFolderPath" == *\)* ]]; then
                # Write new path to prefs file.
                defaults write "$gUserPrefsFile" SaveDirectory "$gReportsFolderPath"
            fi 
        fi
   fi
   
   # Check if path contains parenthesis - if yes, do not report back.
   if [[ ! "$gReportsFolderPath" == *\(* ]] && [[ ! "$gReportsFolderPath" == *\)* ]]; then
   
       CheckForExistingReportsDirAndAppend
   
       # remove temp file holding file path.
       if [ -f "$gDDTmpFolder"/dd_reports_filepath ]; then
           rm "$gDDTmpFolder"/dd_reports_filepath
       fi
       
       # Write new (or old) path to file for UI to read.
       echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath
       echo "*Save path: User changed to $gReportsFolderPath" >> "$gTmpPreLogFile"
   fi

   # Send message to UI to let it know it's no longer waiting for user action
   echo "Done" > "$gDDTmpFolder"/dd_waiting
   
   # As the JS looks for the string Done in "$gDDTmpFolder"/dd_waiting, the
   # UI file browser dialog will not be drawn again while it's still present.
   # Simple solution is to wait 1 second then delete the file.
   sleep 1
   rm "$gDDTmpFolder"/dd_waiting
}

# ---------------------------------------------------------------------------------------
ClearSaveDirectory()
{
    # remove temp file holding file path.
    if [ -f "$gDDTmpFolder"/dd_reports_filepath ]; then
        rm "$gDDTmpFolder"/dd_reports_filepath
    fi

    # delete save path from prefs
    defaults delete "$gUserPrefsFile" SaveDirectory
    
    gReportsFolderPath=""
}

# ---------------------------------------------------------------------------------------
OpenSaveDirectory()
{
    # open file path.
    if [ -f "$gDDTmpFolder"/dd_reports_filepath ]; then
        local filepath=$( cat "$gDDTmpFolder"/dd_reports_filepath )
        open $filepath
    fi
}

# ---------------------------------------------------------------------------------------
GetAndCheckUIPassword()
{
    message="$1" # Commas in the message cause it to fail!
    
    # Send message to UI to tell it we're waiting for user authentication
    echo "Waiting" > "$gDDTmpFolder"/dd_auth 
        
    # revoke sudo permissions
    sudo -k
    
    gPw="$( /usr/bin/osascript << EOF -e 'set MyApplVar to do shell script "echo '"${message}"'"' -e 'Tell application "System Events" to display dialog MyApplVar default answer "" with hidden answer with icon 1' -e 'text returned of result' 2>/dev/null)"
    if [ ! "$gPw" == "" ]; then
        userNow=$( echo "$gPw" | sudo -S whoami )
        if [ "$userNow" == "root" ]; then
            return 0
        else
            return 1
        fi
    else
        # user canelled
        gPw="$gUiPwCancelledStr"

        ## Send message to UI to tell it no longer waiting for user authentication
        #echo "Done" > "$gDDTmpFolder"/dd_auth  
        ClearAuthMessage
    fi
}

# ---------------------------------------------------------------------------------------
UIReturnSymlink()
{
    local uiReturn="$1"
    
    # remove temp file holding symlink info.
    if [ -f "$gDDTmpFolder"/dd_symlink ]; then
        rm "$gDDTmpFolder"/dd_symlink
    fi 
    
    # remove everything up until, and including, the last colon
    uiReturn="${uiReturn##*:}"
    
    if [[ $uiReturn == *Symlink ]]; then # NOTE: uiReturn can be either "Create Symlink", "Update Symlink" or "Delete Symlink"
    
        GetAndCheckUIPassword "DarwinDumper requires your password to manage the symlink. Type your password to allow this."
        returnValueRoot=$? # 1 = not root / 0 = root

        if [ ${returnValueRoot} = 0 ] && [ ! "$gPw" == "" ]; then 
            echo "$gPw" | sudo -S "$uiSudoChanges" "Symlink" "$SELF_PATH" "$uiReturn" && gPw=""
                
            # Get the status of the app symlink
            CheckSymLink
            
            ClearUIReturnMessages
            ClearAuthMessage
            
        elif [ ! "$gPw" == "$gUiPwCancelledStr" ]; then 
            # As long as the user didn't cancel, run again.
            ClearUIReturnMessages
            UIReturnSymlink "$uiReturn"
        fi
    fi 
}

# ---------------------------------------------------------------------------------------
UIReturnFixOwnPerm()
{
    GetAndCheckUIPassword "DarwinDumper requires your password to fix ownership/permissions. Type your password to allow this."
    returnValueRoot=$? # 1 = not root / 0 = root

    if [ ${returnValueRoot} = 0 ] && [ ! "$gPw" == "" ]; then 
        echo "Fixing" > "$gDDTmpFolder"/dd_dumpfolder
        echo "$gPw" | sudo -S "$uiSudoChanges" "OwnPerm" "${DD_BOSS}" "${DD_BOSSGROUP}" "${gReportsFolderPath}" && gPw=""
      
        # Check change was successful
        CheckPathIsWriteable "$gReportsFolderPath"
        returnValueWriteable=$? # 1 = not writeable / 0 = writeable
           
        # If owner is root OR we can not write to it
        if [ ${returnValueWriteable} = 1 ]; then 
            echo "NoWrite" > "$gDDTmpFolder"/dd_dumpfolder 
        else
            echo "The $gAppReportsFolderName folder can now be written to."
            echo "Success" > "$gDDTmpFolder"/dd_dumpfolder 
        fi
        
    elif [ ! "$gPw" == "$gUiPwCancelledStr" ]; then 
        # As long as the user didn't cancel, run again.
        UIReturnFixOwnPerm
    elif [ "$gPw" == "$gUiPwCancelledStr" ]; then 
        # user cancelled
        echo "NoWrite" > "$gDDTmpFolder"/dd_dumpfolder 
    fi
}

# ---------------------------------------------------------------------------------------
WritePrefsToFile()
{
    # Write prefs file
    if [ -f "$gUserPrefsFile".plist ]; then
        defaults delete "$gUserPrefsFile"
    fi

    # Read the temp file then remove it.
    oIFS="$IFS"; IFS=$','
    uiReturnArray=( $(cat "$gDDTmpFolder"/dd_ui_return) )
    IFS="$oIFS"
    
    # Loop through each option
    for (( x=0; x<${#uiReturnArray[@]}; x++ ))
    do
        # Remove unwanted characters and parse results.
        case "${uiReturnArray[$x]##*:}" in
                #"enablehtml")             defaults write "$gUserPrefsFile" enablehtml True ;;
                #"collapsetables")         defaults write "$gUserPrefsFile" collapsetables True ;;
                "privacy")                 defaults write "$gUserPrefsFile" privacy True ;;
                "ReportNew")               defaults write "$gUserPrefsFile" ReportNew True ;;
                "ReportClassicCollapsed")  defaults write "$gUserPrefsFile" ReportClassicCollapsed True ;;
                "ReportClassic")           defaults write "$gUserPrefsFile" ReportClassic True ;;
                "ReportNone")              defaults write "$gUserPrefsFile" ReportNone True ;;
                "ArchiveZip")              defaults write "$gUserPrefsFile" ArchiveZip True ;;
                "ArchiveLzma")             defaults write "$gUserPrefsFile" ArchiveLzma True ;;
                "ArchiveNone")             defaults write "$gUserPrefsFile" ArchiveNone True ;;
                "acpi")                    defaults write "$gUserPrefsFile" acpi True ;;
                "asl")                     defaults write "$gUserPrefsFile" asl True ;;
                "codecid")                 defaults write "$gUserPrefsFile" codecid True ;;
                "cpuinfo")                 defaults write "$gUserPrefsFile" cpuinfo True ;;
                "biosSystem")              defaults write "$gUserPrefsFile" biosSystem True ;;
                "biosVideo")               defaults write "$gUserPrefsFile" biosVideo True ;;
                "devprop")                 defaults write "$gUserPrefsFile" devprop True ;;
                "diskLoaderConfigs")       defaults write "$gUserPrefsFile" diskLoaderConfigs True ;;
                "bootLoaderBootSectors")   defaults write "$gUserPrefsFile" bootLoaderBootSectors True ;;
                "diskPartitionInfo")       defaults write "$gUserPrefsFile" diskPartitionInfo True ;;
                "dmi")                     defaults write "$gUserPrefsFile" dmi True ;;
                "edid")                    defaults write "$gUserPrefsFile" edid True ;;
                "firmlog")                 defaults write "$gUserPrefsFile" firmlog True ;;
                "firmmemmap")              defaults write "$gUserPrefsFile" firmmemmap True ;;
                "ioreg")                   defaults write "$gUserPrefsFile" ioreg True ;;
                "kerneldmesg")             defaults write "$gUserPrefsFile" kerneldmesg True ;;
                "kernelinfo")              defaults write "$gUserPrefsFile" kernelinfo True ;;
                "kexts")                   defaults write "$gUserPrefsFile" kexts True ;;
                "lspci")                   defaults write "$gUserPrefsFile" lspci True ;;
                "rcscripts")               defaults write "$gUserPrefsFile" rcscripts True ;;
                "nvram")                   defaults write "$gUserPrefsFile" nvram True ;;
                "opencl")                  defaults write "$gUserPrefsFile" opencl True ;;
                "rtc")                     defaults write "$gUserPrefsFile" rtc True ;;
                "smc")                     defaults write "$gUserPrefsFile" smc True ;;
                "sysprof")                 defaults write "$gUserPrefsFile" sysprof True ;;
                "noshow")                  defaults write "$gUserPrefsFile" noshow True ;;
        esac
    done
    defaults write "$gUserPrefsFile" SaveDirectory "$gReportsFolderPath"

    # Set the ownership & permissions so it's readable.
    # This covers the case where creating the file as root.
    setPrefsOwnPerms
}

# ---------------------------------------------------------------------------------------
UIReturnRunRequest()
{
    oIFS="$IFS"; IFS=$','
    local uiReturn=$(cat "$gDDTmpFolder"/dd_ui_return)
    IFS="$oIFS"

    if [ $gFaceless -eq 0 ]; then
        WritePrefsToFile
    fi

    # Discover if user chose to run as root or not.
    local discoverRoot="${uiReturn##*:}"
    discoverRoot="${discoverRoot##*=}"
    discoverRoot="${discoverRoot%%,*}"

    if [ $discoverRoot -eq 1 ]; then
        # User chose to run as root.

        GetAndCheckUIPassword "DarwinDumper requires your password to run the selected dumps with root privileges. Type your password to allow this."
        returnValueRoot=$? # 1 = not root / 0 = root

        if [ ${returnValueRoot} = 0 ] && [ ! "$gPw" == "" ]; then 

            ClearAuthMessage
            if [ "$gPw" == "$gUiPwCancelledStr" ]; then
                # user cancelled.
                ClearUIReturnMessages
                # Send UI message to reset all status' to idle.
                printf "X" >> "$gDDTmpFolder"/dd_completed
            else
                echo "$gPw" | sudo -S "${darwinDumperScript}" && gPw=""
                runOrQuit=1
            fi
        fi

    elif [ $discoverRoot -eq 0 ]; then
        # User chose to run without root privileges.
        "${darwinDumperScript}"
        runOrQuit=1
    fi

    return $runOrQuit
}

# ---------------------------------------------------------------------------------------
setPrefsOwnPerms()
{
    if [ -f "$gUserPrefsFile".plist ]; then
        chmod 755 "$gUserPrefsFile".plist
        chown "$theBoss":"$theBossGroup" "$gUserPrefsFile".plist
    fi
}

# ---------------------------------------------------------------------------------------
PerformRunChecks()
{
    DoesSavePathExist "$gReportsFolderPath"
    local pathExist=$? # 1 = no / 0 = yes
    if [ ${pathExist} = 0 ]; then

        CheckPathIsWriteable "$gReportsFolderPath"
        local WriteablePath=$? # 1 = no / 0 = yes
                    
        CheckSavePathForReportsName
        local hasReportsName=$? # 1 = no / 0 = yes
        if [ ${hasReportsName} = 1 ]; then
            gReportsFolderPath="${gReportsFolderPath}/${gAppReportsFolderName}"
        fi

        # If path is writable but DarwinDumperReports directory does not exist,
        # then create report directory. Only run if successful.
        if [ ${WriteablePath} = 0 ]; then
            if [ ${hasReportsName} = 1 ]; then
                createSaveDirAndSetPermissions "$gReportsFolderPath" "normal" "CreateSet" "UI" ""
                local returnMessage=$? # 1 = no / 0 = yes
                if [ ${returnMessage} = 0 ]; then
                    runDarwinDumperScript
                else
                    StopErrorPrintMessage "UI: STOP1"
                fi
            fi

        # If path is NOT writable AND DarwinDumperReports directory does not exist,
        # then create report directory. Only run if successful.    
        else
            if [ ${hasReportsName} = 1 ]; then
                createSaveDirAndSetPermissions "$gReportsFolderPath" "sudo" "CreateSet" "UI" "DarwinDumper requires root privileges to create the reports directory at your selected path: $gReportsFolderPath. Type your password to allow this."
                local returnMessage=$? # 1 = no / 0 = yes
                if [ ${returnMessage} = 0 ]; then
                    runDarwinDumperScript
                else
                    StopErrorPrintMessage "UI: STOP2"
                fi

            # If path is NOT writable AND DarwinDumperReports directory does exist,
            # then attempt to set ownership/permissions for the report directory. 
            # Only run if successful.   
            else
                createSaveDirAndSetPermissions "$gReportsFolderPath" "sudo" "Set" "UI" "DarwinDumper requires root privileges to change ownership/permission to the reports directory. Type your password to allow this."
                local returnMessage=$? # 1 = no / 0 = yes
                if [ ${returnMessage} = 0 ]; then
                    runDarwinDumperScript
                else
                    StopErrorPrintMessage "UI: STOP3"
                fi
            fi
        fi
                    
        # If path is writable AND DarwinDumperReports directory exists,
        # then run.  
        if [ ${WriteablePath} = 0 ]; then
            if [ ${hasReportsName} = 0 ]; then
                runDarwinDumperScript
            fi
        fi                     
    else
        echo "*Save path: Error - Save path does not exist." >> "${gTmpPreLogFile}"
        # Send message to UI to notify the user
        echo "path_error" > "$gDDTmpFolder"/dd_error 
        ClearUIReturnMessages
        ClearUIErrorMessage
        # Do nothing else, so return to main loop.
    fi
}

# ---------------------------------------------------------------------------------------
runDarwinDumperScript()
{
# Write save path to file for DarwinDumper script to use.
    echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath
    UIReturnRunRequest
    runOrQuit=$? # Will initiate exit of main loop.
}
                    
# ---------------------------------------------------------------------------------------
runUI()
{
    # Run the webview user interface as a child process
    # and direct it's results to a temporary file.
    `"${macgap}" &>"$gDDTmpFolder"/dd_ui_return` & pidDDUI=$! ; flagDDUI=0

    # Provide feedback.
    echo "DarwinDumper user interface is running."
    echo "Waiting for user..."
    
    # Check save path
    if [ ! "$gReportsFolderPath" == "" ]; then
    
        DoesSavePathExist "$gReportsFolderPath"
        local pathExist=$? # 1 = no / 0 = yes
        if [ ${pathExist} = 1 ]; then
            echo "*Error - Save path does not exist." >> "${gTmpPreLogFile}"
            # Write save path to file so UI can print it in dialog box.
            echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath
            # Send message to UI to notify the user
            echo "path_error" > "$gDDTmpFolder"/dd_error 
            ClearUIErrorMessage
        fi
    fi
    CheckAndFixBlankSavePath
    
    # Write save path to file.
    echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath

    # Check to see if symbolic link in /usr/local/bin/ has been created.
    CheckSymLink

    # Check to see if there's an update available
    CheckForUpdate

    local pw=""
    local userNow=""
    local runOrQuit=0
    while [ $runOrQuit -eq 0 ];
    do

        # Wait until temporary file exists and is greater than zero in size.
        while [ ! -s "$gDDTmpFolder"/dd_ui_return ];
        do
            sleep 0.25  # Check every 1/4 second.
        done

        # Check to see if user quit or not.
        if ! grep "user_quit" "$gDDTmpFolder"/dd_ui_return ; then

           # Is the UI informing that the user pressed the Symlink button?
            if grep "Symlink:" "$gDDTmpFolder"/dd_ui_return ; then
                local uiReturn=$(cat "$gDDTmpFolder"/dd_ui_return)
                UIReturnSymlink "$uiReturn"

            # Has the UI informed that the status bars have been reset to idle?
            elif grep "idle" "$gDDTmpFolder"/dd_ui_return ; then
                  ClearUIReturnMessages
                  > "$gDDTmpFolder"/dd_completed                   # Clear $gDDTmpFolder/dd_completed as UI has now been reset.

            # Has the user agreed to fix ownership/permissions for Reports folder?
            elif grep "Fix" "$gDDTmpFolder"/dd_ui_return ; then
                  ClearUIReturnMessages
                  UIReturnFixOwnPerm

            # Has the UI returned an error message?
            elif grep "console" "$gDDTmpFolder"/dd_ui_return ; then
                  cat "$gDDTmpFolder"/dd_ui_return > ~/Desktop/DarwinDumperError.txt
                  ClearUIReturnMessages
                  echo "An error occurred. DarwinDumperError.txt was written to your Desktop."
                  echo "Exiting. Bye"
                  runOrQuit=1

            # Is the UI informing that the user wants to change the SaveDirectory?
            elif grep "saveDirectory" "$gDDTmpFolder"/dd_ui_return ; then
                local uiReturn=$(cat "$gDDTmpFolder"/dd_ui_return)
                ClearUIReturnMessages
                GetNewSaveDirectory

            # Is the UI informing that the user wants to clear the SaveDirectory?
            elif grep "clearSaveDirectory" "$gDDTmpFolder"/dd_ui_return ; then
                local uiReturn=$(cat "$gDDTmpFolder"/dd_ui_return)
                ClearUIReturnMessages
                ClearSaveDirectory
                CheckAndFixBlankSavePath
                # Write save path to file for DarwinDumper script to use.
                echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath
                
            # Is the UI informing that the user wants to open the SaveDirectory?
            elif grep "openSaveDirectory" "$gDDTmpFolder"/dd_ui_return ; then
                local uiReturn=$(cat "$gDDTmpFolder"/dd_ui_return)
                ClearUIReturnMessages
                OpenSaveDirectory

            # The UI is returning instructions for the dump options the user wants to run.
            else
                # Add temporary catch for 10.10 DP2 errors??
                tmp=$( grep "TSplicedFont" "$gDDTmpFolder"/dd_ui_return )
                if [ "$tmp" == "" ]; then
                    echo "*UI: User clicked the run button" >> "${gTmpPreLogFile}"
                    PerformRunChecks
                else
                    ClearUIReturnMessages
                fi
            fi
        else
            echo "User Quit. Bye"
            runOrQuit=1
        fi
    done

    # Wait until process ends.
    c=0
    while sleep 0.5; do      
        kill -0 $pidDDUI &> /dev/null || if [ $flagDDUI -eq 0 ]; then ((c++)); flagDDUI=1; fi
        if [ $c -eq 1 ]; then
            break
        fi
    done
}

# ---------------------------------------------------------------------------------------
runCommandLine()
{
    local passedUser="$1"
    
    CheckAndFixBlankSavePath
    CheckForExistingReportsDirAndAppend
    
    DoesSavePathExist "$gReportsFolderPath"
    local pathExist=$? # 1 = no / 0 = yes
    if [ ${pathExist} = 1 ]; then
        echo "--------------------------------------------------------------------"
        echo "*Save path: Error - Save path does not exist." >> "${gTmpPreLogFile}"
        echo "Custom save path from user prefs does not exist, setting to default" 
        gReportsFolderPath=""
        CheckAndFixBlankSavePath
        CheckForExistingReportsDirAndAppend
        echo "Save path is now: $gReportsFolderPath"  
        echo "--------------------------------------------------------------------"                
    fi

    CheckPathIsWriteable "$gReportsFolderPath"
    local WriteablePath=$? # 1 = no / 0 = yes

    CheckSavePathForReportsName
    local hasReportsName=$? # 1 = no / 0 = yes
    if [ ${hasReportsName} = 1 ]; then
        gReportsFolderPath="${gReportsFolderPath}/${gAppReportsFolderName}"
    fi
    
    # If path is writable but DarwinDumperReports directory does not exist,
    # then create report directory. Only run if successful.
    if [ ${WriteablePath} = 0 ]; then
        if [ ${hasReportsName} = 1 ]; then
            echo "------------------------------------------------------------------------"
            echo "Save path is writeable but DarwinDumperReports directory does not exist." 
            echo "Attempting to creating DarwinDumperReports directory..." 
            echo "------------------------------------------------------------------------"
            createSaveDirAndSetPermissions "$gReportsFolderPath" "normal" "CreateSet" "CL" ""
            local returnMessage=$? # 1 = no / 0 = yes
            if [ ${returnMessage} = 0 ]; then
                runDarwinDumperScriptCL "$passedUser"
            else
                StopErrorPrintMessage "CL: STOP1"
            fi
        fi
        
    # If path is NOT writable AND DarwinDumperReports directory does not exist,
    # then create report directory and set permissions. Only run if successful.    
    else
        if [ ${hasReportsName} = 1 ]; then
            echo "----------------------------------------------------------------------------"
            echo "Save path is not writeable and DarwinDumperReports directory does not exist." 
            echo "Attempting to creating DarwinDumperReports directory and set permissions..." 
            echo "----------------------------------------------------------------------------"
            createSaveDirAndSetPermissions "$gReportsFolderPath" "sudo" "CreateSet" "CL" ""
            local returnMessage=$? # 1 = no / 0 = yes
            if [ ${returnMessage} = 0 ]; then
                runDarwinDumperScriptCL "$passedUser"
            else
                StopErrorPrintMessage "CL: STOP2"
            fi

        # If path is NOT writable AND DarwinDumperReports directory does exist,
        # then attempt to set ownership/permissions for the report directory. 
        # Only run if successful.   
        else
            echo "----------------------------------------------------------------"
            echo "DarwinDumperReports directory does exist but it's not writeable." 
            echo "Attempting to set permissions..." 
            echo "----------------------------------------------------------------"
            createSaveDirAndSetPermissions "$gReportsFolderPath" "sudo" "Set" "CL" ""
            local returnMessage=$? # 1 = no / 0 = yes
            if [ ${returnMessage} = 0 ]; then
                runDarwinDumperScriptCL "$passedUser"
            else
                StopErrorPrintMessage "CL: STOP3"
            fi
        fi
    fi
                 
    # If path is writable AND DarwinDumperReports directory exists,
    # then run.  
    if [ ${WriteablePath} = 0 ]; then
        if [ ${hasReportsName} = 0 ]; then
            runDarwinDumperScriptCL "$passedUser"
        fi
    fi
}

# ---------------------------------------------------------------------------------------
runDarwinDumperScriptCL()
{
    local passedUser="$1"
    if [ $gFaceless -eq 0 ]; then
        WritePrefsToFile
    fi
    echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath
    if [ "$passedUser" == "" ]; then
        # Run main script - without root privileges.
        "$darwinDumperScript"
    elif [ "$passedUser" == "r" ]; then
        # Run main script - with root privileges.
        sudo "${darwinDumperScript}"
    fi
}

# ---------------------------------------------------------------------------------------
StopErrorPrintMessage()
{
    passedError="$1"
    echo "===========================================================" >> "$gTmpPreLogFile"
    echo "Error: $passedError" >> "$gTmpPreLogFile"
    echo "-----------------------------------------------------------" >> "$gTmpPreLogFile"
    echo "To help improve DarwinDumper, please send the containing temporary directory" >> "$gTmpPreLogFile"
    echo "together with a description of the problem to either of the following links:" >> "$gTmpPreLogFile"
    echo "http://www.insanelymac.com/forum/topic/282794-darwindumper/" >> "$gTmpPreLogFile"
    echo "http://www.projectosx.com/forum/index.php?showtopic=2447" >> "$gTmpPreLogFile"
    echo "-----------------------------------------------------------" >> "$gTmpPreLogFile"  
    echo "" >> "$gTmpPreLogFile"
    echo "Thank you" >> "$gTmpPreLogFile"
    
    if [[ "$passedError" == *UI* ]]; then
        open "$gTmpPreLogFile"
        # Close the UI
        echo "Done" >> "$gDDTmpFolder"/dd_completed
        if [ -f "$gDDTmpFolder"/dd_completed ]; then
            chmod 755 "$gDDTmpFolder"/dd_completed
            chown "${theBoss}":"$theBossGroup" "$gDDTmpFolder"/dd_completed
        fi
    fi
    
    if [[ "$passedError" == *CL* ]]; then
        echo "==========================================================="
        echo "Error: $passedError"
        echo "-----------------------------------------------------------"
        echo "An error has occurred."
        echo "To help improve DarwinDumper, please send the temporary directory:"
        echo "$gDDTmpFolder"
        echo "together with a description of the problem to either of the following links:"
        echo "http://www.insanelymac.com/forum/topic/282794-darwindumper/"
        echo "http://www.projectosx.com/forum/index.php?showtopic=2447"
        echo "-----------------------------------------------------------"
        echo""
        echo "Thank you"  
    fi

    exit 1          
}

# ---------------------------------------------------------------------------------------
DeleteTempWorkingDirectory()
{
    if [ -d "$gDDTmpFolder" ]; then
        rm -rf "$gDDTmpFolder"
    fi
}

# -----------------------------------
# MAIN

# Remove any temp files as a precautionary measure.
# Just incase the app crashed and didn't clean up.
DeleteTempWorkingDirectory

# Create temporary working directory.
mkdir "$gDDTmpFolder"

# Was this script called from a script or the command line
# More info: # http://stackoverflow.com/questions/4261876/check-if-bash-script-was-invoked-from-a-shell-or-another-script-application
#identityCaller=`ps -o stat= -p $PPID`
identityCallerCheck=`ps -o stat= -p $$`

if [ "${identityCallerCheck:1:1}" == "+" ]; then

    # Called from command line so interpret arguments.    
    # For getopts info: http://wiki.bash-hackers.org/howto/getopts_tutorial
    argumentsToPass=""
    wasDumpChosen=0
    
    # Check if any arguments were passed at all.
    if [ $# -ne 0 ]; then 
    
        while getopts ":a:d:hlo:p:rv" opt; do
            case $opt in

              a) # ARCHIVES - Check the arguments
                 oIFS="$IFS"; IFS=$','
                 for o in $OPTARG
                 do
                     case "$o" in
                        "zip")              argumentsToPass="${argumentsToPass},ArchiveZip" ;;
                        "lzma")             argumentsToPass="${argumentsToPass},ArchiveLzma" ;;
                        "none")             argumentsToPass="${argumentsToPass},ArchiveNone" ;;
                             *)             echo "Invalid archive option: -$OPTARG" >&2
                                            exit 1
                                            ;;    
                     esac
                 done
                 ;;  

              d) # DUMPS -  Check the arguments
                 oIFS="$IFS"; IFS=$','
                 for o in $OPTARG
                 do
                     case "$o" in
                        "acpi")              argumentsToPass="${argumentsToPass},acpi"
                                             wasDumpChosen=1 ;;
                        "asl")               argumentsToPass="${argumentsToPass},asl"
                                             wasDumpChosen=1 ;;
                        "audio")             argumentsToPass="${argumentsToPass},codecid"
                                             wasDumpChosen=1 ;;
                        "biosSystem")        argumentsToPass="${argumentsToPass},biosSystem"
                                             wasDumpChosen=1 ;;
                        "biosVideo")         argumentsToPass="${argumentsToPass},biosVideo"
                                             wasDumpChosen=1 ;;
                        "cpuinfo")           argumentsToPass="${argumentsToPass},cpuinfo"
                                             wasDumpChosen=1 ;; 
                        "devprop")           argumentsToPass="${argumentsToPass},devprop"
                                             wasDumpChosen=1 ;;
                        "diskLoaderConfigs") argumentsToPass="${argumentsToPass},diskLoaderConfigs"
                                             wasDumpChosen=1 ;;
                        "bootLoaderBootSectors")   argumentsToPass="${argumentsToPass},bootLoaderBootSectors"
                                             wasDumpChosen=1 ;;
                        "diskVolumeXuid")    argumentsToPass="${argumentsToPass},diskVolumeXuid"
                                             wasDumpChosen=1 ;;
                        "diskPartitionInfo") argumentsToPass="${argumentsToPass},diskPartitionInfo"
                                             wasDumpChosen=1 ;;
                        "dmi")               argumentsToPass="${argumentsToPass},dmi"
                                             wasDumpChosen=1 ;;
                        "edid")              argumentsToPass="${argumentsToPass},edid"
                                             wasDumpChosen=1 ;;
                        "firmlog")           argumentsToPass="${argumentsToPass},firmlog"
                                             wasDumpChosen=1 ;;
                        "firmmemmap")        argumentsToPass="${argumentsToPass},firmmemmap"
                                             wasDumpChosen=1 ;;
                        "ioreg")             argumentsToPass="${argumentsToPass},ioreg"
                                             wasDumpChosen=1 ;;
                        "kerneldmesg")       argumentsToPass="${argumentsToPass},kerneldmesg"
                                             wasDumpChosen=1 ;;
                        "kernelinfo")        argumentsToPass="${argumentsToPass},kernelinfo"
                                             wasDumpChosen=1 ;;
                        "kexts")             argumentsToPass="${argumentsToPass},kexts"
                                             wasDumpChosen=1 ;;
                        "lspci")             argumentsToPass="${argumentsToPass},lspci"
                                             wasDumpChosen=1 ;;
                        "nvram")             argumentsToPass="${argumentsToPass},nvram"
                                             wasDumpChosen=1 ;;
                        "opencl")            argumentsToPass="${argumentsToPass},opencl"
                                             wasDumpChosen=1 ;;
                        "rcscripts")         argumentsToPass="${argumentsToPass},rcscripts"
                                             wasDumpChosen=1 ;;
                        "rtc")               argumentsToPass="${argumentsToPass},rtc"
                                             wasDumpChosen=1 ;;
                        "smc")               argumentsToPass="${argumentsToPass},smc"
                                             wasDumpChosen=1 ;;
                        "sysprof")           argumentsToPass="${argumentsToPass},sysprof"
                                             wasDumpChosen=1 ;;
                        *)                   echo "Invalid dump: -$OPTARG" >&2
                                             exit 1
                                             ;;    
                     esac
                 done
                 ;;
                 
              h) echo ""
        echo "    -a                      Archive Options"
        echo "                            ----------------------------------------------------"
        echo "        zip                 Compress final dump folder using .zip"
        echo "        lzma                Compress final dump folder using .lzma"
        echo "        none                Do not compress the final dump folder"
        echo ""
        echo "    -d                      Dump Options"
        echo "                            ----------------------------------------------------"
        echo "        acpi                Extract ACPI tables from ioreg and decompile them."  
        echo "        asl                 Reads last boot log from /var/log/asl/"    
        echo "        audio               Run the getcodecid tool & temporarily install"
        echo "                            VoodooHDA.kext to run the getdump tool.*"  
        echo "        biosSystem          Run the flashrom tool to dump system BIOS to file.*"  
        echo "        biosVideo           Temporarily installs RadeonPCI.kext then runs the"
        echo "                            RadeonDump tool to dump video bios. This option"
        echo "                            will also decode the video bios if ATI vendor ID*"
        echo "        cpuinfo             Get CPU info"
        echo "        devprop             Extract device-properties from ioreg and convert"
        echo "                            using the gfxutil tool."
        echo "        diskLoaderConfigs   Scan mounted volumes for bootloader configuration"
        echo "                            files.* Note: requires root privileges to mount &"  
        echo "                            read the EFI system partition."
        echo "        bootLoaderBootSectors     Combines diskutil list with added boot-sector / "
        echo "                            bootloader info.* Note: requires root privileges"  
        echo "                            to mount & read the EFI system partition."  
        echo "        diskVolumeXuid      Dump all Volume UUID's and Unique Partition GUID's*"  
        echo "                            Note: requires root privileges to mount & read the"
        echo "                            EFI system partition."  
        echo "        diskPartitionInfo   Save partition info from fdisk440 & gpt command."
        echo "                            Scan and interpret the disk sectors to build a view"
        echo "                            of the partition tables"
        echo "                            Note: requires root privileges to mount & read the"
        echo "                            EFI system partition."    
        echo "        dmi                 Runs the smbios-reader tool then decodes the info"
        echo "                            using the dmidecode tool."  
        echo "        edid                Extracts IODisplayEDID data from ioreg, then decodes"
        echo "                            it using the edid-decode tool."  
        echo "        firmlog             Extracts the firmware (bootloader) log from ioreg."  
        echo "        firmmemmap          Runs the FirmwareMemoryMap DTrace script to show the"
        echo "                            physical memory map from EFI.*"  
        echo "        ioreg               Extract the live Registry to text file(s) and create"
        echo "                            IORegistry Web Viewer data structure."  
        echo "        kerneldmesg         Dumps kernel boot message log using /sbin/dmesg*"
        echo "        kernelinfo          Dump CPU & Hardware info using /usr/sbin/sysctl"  
        echo "        kexts               Runs /usr/sbin/kextstat to dump the list of"
        echo "                            currently loaded kernel extensions.*"  
        echo "        lspci               Temporarily installs DirectHW.kext then runs the"
        echo "                            lspci tool to dump hardware information.*"  
        echo "        rcscripts           Saves any rc.local and rc.shutdown.local scripts."
        echo "        nvram               Dump the contents of NVRAM."  
        echo "        opencl              Runs the oclinfo tool to print data for compliant"
        echo "                            OpenCL devices."  
        echo "        rtc                 Runs the cmosDumperForOsx tool to dump the current"
        echo "                            RTC registers."  
        echo "        smc                 Dumps all SMC keys to file using the SMC_util3 tool."  
        echo "        sysprof             Runs /usr/sbin/system_profiler to save mini (non-"
        echo "                            sensitive contents) files (.xml and .txt)."
        echo ""
        echo "    -l                      Last settings (Use last options saved in user prefs)"
        echo ""
        echo "    -o                      Options"
        echo "                            ----------------------------------------------------"
        echo "        htmlnew             Build HTML report file from dump information."
        echo "        htmlclassiccollapsedClassic style report - collapsed (hidden) DIV's."
        echo "        htmlclassic         Classic style report - all DIV's visible on open."
        echo "        private             Mask sensitive data within all the dumps."
        echo ""
        echo "    -p                      Pre-Configured Options"
        echo "                            ----------------------------------------------------"
        echo "        1                   Runs every dump that does not require root"
        echo "                            privileges, creates an HTML report & archives the"
        echo "                            final dump folder using .zip"
        echo "                            ** Use this option on it's own."
        echo "        2                   Runs every dump including those that require root"
        echo "                            privileges, creates an HTML report & archives the"
        echo "                            final dump folder using .zip."
        echo "                            ** Use this option on it's own."
        echo "        3                   Same as p1 but with privacy enabled."
        echo "        4                   Same as p2 but with privacy enabled."
        echo ""
        echo "    -v                      Print the version."
        echo ""
        echo ""
        echo " Note: Items marked with an * require root privileges, to either run at all or"
        echo "       to perform completely."
        echo ""
        echo "Example: darwindumper -d bootLoaderBootSectors -o html,collapsed -a zip -r"
        echo "Example: darwindumper -d smc,edid"
        echo "Example: darwindumper -d devprop,audio,firmlog,lspci"
        echo "Example: darwindumper -p1"
        echo "Example: darwindumper -l"
        echo ""
        ;;

              l) # LAST used options - read from user prefs.
                 LoadPreviousSettingsFromUserPrefs
                 
                 if [ -f "$gDDTmpFolder"/dd_user_last_options ]; then
                     declare -a rootDumps=(codecid biosSystem biosVideo diskLoaderConfigs bootLoaderBootSectors diskVolumeXuid diskPartitionInfo firmmemmap kerneldmesg kexts lspci)
                     readOptions=( $(cat "$gDDTmpFolder"/dd_user_last_options))
                     for (( o=0; o<${#readOptions[@]}; o++ ))
                     do
                         argumentsToPass="$argumentsToPass,${readOptions[$o]}"
                     done
                     wasDumpChosen=1            
                 else
                     echo "Failed to read any previous dump options from prefs file."
                     echo "Please use a different option."
                     exit 1
                 fi
                 ;;
              
              o) # OPTIONS - Check the arguments
                 oIFS="$IFS"; IFS=$','
                 for o in $OPTARG
                 do
                     case "$o" in
                        "htmlnew")                argumentsToPass="${argumentsToPass},ReportNew" ;;
                        "htmlclassiccollapsed")   argumentsToPass="${argumentsToPass},ReportClassicCollapsed" ;;
                        "htmlclassic")            argumentsToPass="${argumentsToPass},ReportClassic" ;;
                        "private")                argumentsToPass="${argumentsToPass},privacy" ;;
                                *)                echo "Invalid option: -$OPTARG" >&2
                                                  exit 1
                                                  ;;    
                     esac
                 done
                 ;; 
              
              p) # PRECONFIGURED - Check the arguments
                 if [ "$OPTARG" == "1" ]; then
                     # Run all without root privileges
                     argumentsToPass=",ArchiveZip,acpi,asl,cpuinfo,devprop,dmi,edid,firmlog,ioreg,kernelinfo,rcscripts,nvram,opencl,rtc,smc,sysprof,ReportNew"
                     wasDumpChosen=1
                 elif [ "$OPTARG" == "2" ]; then
                    # Run as root
                     argumentsToPass=",ArchiveZip,acpi,asl,codecid,biosSystem,biosVideo,cpuinfo,diskLoaderConfigs,devprop,bootLoaderBootSectors,diskVolumeXuid,diskPartitionInfo,dmi,edid,firmlog,firmmemmap,ioreg,kerneldmesg,kernelinfo,kexts,lspci,rcscripts,nvram,opencl,rtc,smc,sysprof,ReportNew"
                     wasDumpChosen=1
                 elif [ "$OPTARG" == "3" ]; then
                     # Run all without root privileges
                     argumentsToPass=",ArchiveZip,acpi,asl,cpuinfo,devprop,dmi,edid,firmlog,ioreg,kernelinfo,rcscripts,nvram,opencl,rtc,smc,sysprof,ReportNew,privacy"
                     wasDumpChosen=1
                 elif [ "$OPTARG" == "4" ]; then
                    # Run as root
                     argumentsToPass=",ArchiveZip,acpi,asl,codecid,cpuinfo,biosSystem,biosVideo,diskLoaderConfigs,devprop,bootLoaderBootSectors,diskVolumeXuid,diskPartitionInfo,dmi,edid,firmlog,firmmemmap,ioreg,kerneldmesg,kernelinfo,kexts,lspci,rcscripts,nvram,opencl,rtc,smc,sysprof,ReportNew,privacy"
                     wasDumpChosen=1
                 fi
                 ;;

              v) echo "DarwinDumper v$VERS"
                 exit 1
                 ;;
              
              \?)
                 echo "Invalid option: -$OPTARG" >&2
                 exit 1
                 ;;
             
              :)
                 echo "Option -$OPTARG requires an argument." >&2
                 exit 1
                 ;;
             
            esac
        done 

         
        if [ ! "$argumentsToPass" == "" ]; then

            # Check to see if a dump was asked for
            if [ $wasDumpChosen -eq 1 ]; then

                # Check if any dumps require root privileges
                declare -a rootDumps=(biosSystem biosVideo diskLoaderConfigs bootLoaderBootSectors diskVolumeXuid diskPartitionInfo firmmemmap kerneldmesg kexts lspci)
                rootFlag=0
                for (( r=0; r<${#rootDumps[@]}; r++ ))
                do
                    # do the arguments contain a dump requiring root privileges?
                    if test "${argumentsToPass#*${rootDumps[$r]}}" != "$argumentsToPass"; then
                        rootFlag=1
                    fi
               done

               if [ $rootFlag -eq 1 ]; then
                    echo "Root privileges are required to complete this task."
                    argumentsToPass=":Root=1${argumentsToPass}"
                    echo "$argumentsToPass" >> "$gDDTmpFolder"/dd_ui_return
                    Initialise "CommandLine" "r"
               else
                    argumentsToPass=":Root=0${argumentsToPass}"
                    echo "$argumentsToPass" >> "$gDDTmpFolder"/dd_ui_return
                    Initialise "CommandLine" ""
               fi

            fi
        else
            exit 1
        fi
        
    else
        # No arguments were passed
        echo "usage: [-a zip,lzma,none] [-d acpi,asl,audio,biosSystem,biosVideo,codecid,cpuinfo,devprop,diskLoaderConfigs,bootLoaderBootSectors,diskVolumeXuid,diskPartitionInfo,dmi,edid,firmlog,firmmemmap,ioreg,kerneldmesg,kernelinfo,kexts,lspci,rcscripts,nvram,opencl,rtc,smc,sysprof] [-h] [-l] [-o html,collapsed,private] [-p 1,2,3,4] [-v]"
    fi
    
else
    # Called from Finder application script so run UI.
    
    # Check for existence of "$gDDTmpFolder"/dd_completed
    # If found, remove.
    if [ -f "$gDDTmpFolder"/dd_completed ]; then
        rm "$gDDTmpFolder"/dd_completed
    fi

    if [ $gFaceless -eq 0 ]; then
        Initialise "Script" ""
    else
        echo ":Root=0,ArchiveZip,acpi,cpuinfo,devprop,dmi,edid,firmlog,ioreg,kernelinfo,rcscripts,nvram,opencl,rtc,smc,sysprof,ReportNew,noshow" >> "$gDDTmpFolder"/dd_ui_return
        Initialise "CommandLine" ""
    fi
fi

DeleteTempWorkingDirectory